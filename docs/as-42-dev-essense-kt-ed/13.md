13.柯特林算子和表达式

到目前为止，我们已经研究了在 Kotlin 中使用变量和常量，并描述了不同的数据类型。然而，能够创造变量只是故事的一部分。下一步是学习如何在 Kotlin 代码中使用这些变量。处理数据的主要方法是表达式的形式。

13.1柯特林中的表达式语法

最基本的表达式由一个运算符、两个操作数和一个赋值组成。以下是表达式的示例:

```kt
val myresult = 1 + 2
```

在上面的示例中，使用(+)运算符将两个操作数(1 和 2)相加。赋值运算符(=)随后将加法结果赋给名为 myresult 的变量。操作数很可能只是变量(或者值和变量的混合)，而不是示例中使用的实际数值。

在本章的剩余部分，我们将了解 Kotlin 中可用的基本运算符类型。

13.2 基本赋值运算符

我们已经了解了最基本的赋值运算符，即=运算符。这个赋值运算符只是将表达式的结果赋给一个变量。本质上，赋值运算符=接受两个操作数。左边的操作数是要赋值的变量，右边的操作数是要赋值的值。右边的操作数通常是一个表达式，它执行某种算术或逻辑计算或对函数的调用，其结果将赋给变量。以下示例都是赋值运算符的有效用法:

```kt
var x: Int // Declare a mutable Int variable
val y = 10 // Declare and initialize an immutable Int variable

x = 10 // Assign a value to x
x = x + y // Assign the result of x + y to x
x = y // Assign the value of y to x
```

13.3 柯特林算术运算符

Kotlin 提供了一系列运算符来创建数学表达式。这些运算符主要属于二进制运算符的范畴，因为它们接受两个操作数。例外情况是一元负运算符(-)，它用于指示值是负的而不是正的。这与采用两个操作数(即一个值要从另一个值中减去)的减法运算符(-)形成对比。例如:

```kt
var x = -10 // Unary - operator used to assign -10 to variable x
x = x - 5 // Subtraction operator. Subtracts 5 from x
```

下表列出了主要的柯特林算术运算符:

<colgroup><col> <col></colgroup> 
| 操作员 | 描述 |
| -(一元) | 否定变量或表达式的值 |
| * | 增加 |
| / | 分开 |
| + | 添加 |
| - | 减法 |
| % | 余数/模 |

表 13-1

请注意，一个表达式中可以使用多个运算符。

例如:

```kt
x = y * 10 + z - 5 / 4
```

13.4 增广赋值运算符

在前面的部分中，我们研究了基本赋值运算符(=)。Kotlin 提供了许多运算符，旨在将赋值与数学或逻辑运算相结合。这些主要在执行计算时使用，计算结果将存储在一个操作数中。例如，可以编写如下表达式:

```kt
x = x + y
```

上面的表达式将变量 x 中包含的值与变量 y 中包含的值相加，并将结果存储在变量 x 中。这可以通过使用加法增强赋值运算符来简化:

```kt
x += y
```

上面的表达式执行与 x = x + y 完全相同的任务，但是为程序员节省了一些打字时间。

Kotlin 中有许多增广赋值运算符。下表列出了最常用的方法:

<colgroup><col> <col></colgroup> 
| 操作员 | 描述 |
| x += y | 将 x 加到 y，并将结果放在 x 中 |
| x -= y | 从 x 中减去 y，并将结果放在 x 中 |
| x *= y | 将 x 乘以 y，并将结果放入 x 中 |
| x /= y | 用 x 除以 y，并将结果放入 x 中 |
| x %= y | 对 x 和 y 执行模运算，并将结果放在 x 中 |

表 13-2

13.5 增量和 减量运算符

使用 Kotlin 递增和递减运算符(也称为一元运算符，因为它们对单个操作数进行操作)可以实现另一个有用的快捷方式。考虑下面的代码片段:

```kt
x = x + 1 // Increase value of variable x by 1
x = x - 1 // Decrease value of variable x by 1
```

这些表达式将 x 的值递增和递减 1。然而，使用++和--运算符比使用这种方法更快。以下示例执行与上述示例完全相同的任务:

```kt
x++ // Increment x by 1
x-- // Decrement x by 1
```

这些运算符可以放在变量名之前或之后。如果将运算符放在变量名之前，则在对变量执行任何其他操作之前，先执行递增或递减操作。例如，在下面的代码中，x 在分配给 y 之前先递增，y 的值为 10:

```kt
var x = 9
val y = ++x
```

然而，在下一个示例中，在执行减量之前，x (9)的值被分配给变量 y。表达式求值后，y 的值将是 9，x 的值将是 8。

```kt
var x = 9
val y = x--
```

13.6 平等运营商

Kotlin 还包括一组用于执行比较的逻辑运算符。这些运算符都根据比较结果返回一个布尔结果。这些运算符是二元运算符，因为它们使用两个操作数。

等式运算符最常用于构造程序流控制逻辑。例如，可以基于一个值是否与另一个值匹配来构造 if 语句:

```kt
if (x == y) {
      // Perform task
}
```

比较的结果也可以存储在布尔变量中。例如，以下代码将导致变量结果中存储一个真值:

```kt
var result: Bool
val x = 10
val y = 20

result = x < y
```

很明显，10 小于 20，导致 x < y 表达式的真实评估。下表列出了 Kotlin 比较运算符的完整集合:

<colgroup><col> <col></colgroup> 
| 操作员 | 描述 |
| x == y | 如果 x 等于 y，则返回真 |
| x > y | 如果 x 大于 y，则返回真 |
| x >= y | 如果 x 大于或等于 y，则返回 true |
| x < y | 如果 x 小于 y，则返回真 |
| x <= y | 如果 x 小于或等于 y，则返回 true |
| x！= y | 如果 x 不等于 y，则返回真 |

表 13-3

13.7 布尔 逻辑运算符

Kotlin 还提供了一组所谓的逻辑运算符，旨在返回布尔真值或假值。这些运算符既返回布尔结果，又将布尔值作为操作数。关键操作符不是(！)，AND (&&)和 OR (||)。

NOT(！)运算符只是将布尔变量的当前值或表达式的结果反转。例如，如果名为 flag 的变量当前为 true，则在变量前面加上“！”字符会将该值反转为 false:

```kt
val flag = true // variable is true
val secondFlag = !flag // secondFlag set to false
```

如果 OR (||)运算符的两个操作数中有一个计算结果为真，则该运算符返回真，否则返回假。例如，以下代码的计算结果为真，因为“或”运算符两侧的表达式中至少有一个为真:

```kt
if ((10 < 20) || (20 < 10)) {
        print("Expression is true")
}
```

“与”(&&)运算符只有在两个操作数都计算为真时才返回真。以下示例将返回 false，因为两个操作数表达式中只有一个计算结果为 true:

```kt
if ((10 < 20) && (20 < 10)) {
      print("Expression is true")
}
```

13.8 靶场主任

Kotlin 包含一个有用的运算符，允许声明一系列值。正如将在后面章节中看到的，当在程序逻辑中使用循环时，这个操作符是非常宝贵的。

范围运算符的语法如下:

```kt
x..y
```

该运算符表示从 x 开始到 y 结束的数字范围，其中 x 和 y 都包含在该范围内(称为封闭范围)。范围运算符 5..例如，8 指定数字 5、6、7 和 8。

13.9 按位运算符

如前所述，计算机处理器以二进制方式工作。这些基本上是 1 和 0 的流，每一个被称为一位。位被分成 8 个一组，形成字节。因此，作为程序员，我们偶尔会在代码中以这种水平工作，这并不奇怪。为了满足这一要求，Kotlin 提供了一系列位操作符。

那些熟悉其他语言(如 C、C++、C#、Objective-C 和 Java)中的按位运算符的人，在柯特林语言语法的这一领域不会发现什么新东西。对于那些不熟悉二进制数的人来说，现在可能是寻找关于这个主题的参考资料的好时机，以便理解 1 和 0 是如何形成字节以形成数字的。其他作者在描述这个主题方面做得比我们在这本书的范围内所能做的好得多。

出于本练习的目的，我们将使用两个数字的二进制表示。首先，十进制数 171 用二进制表示为:

```kt
10101011
```

其次，数字 3 由以下二进制序列表示:

```kt
00000011
```

现在我们有了两个可以使用的二进制数，我们可以开始查看 Kotlin 按位运算符:

13.9.1 逐位反转

按位反转(也称为“非”)是使用 inv()操作执行的，具有反转一个数字中所有位的效果。换句话说，所有的 0 变成 1，所有的 1 变成 0。以我们的示例 3 为例，按位非运算有以下结果:

```kt
00000011 NOT
========
11111100
```

因此，下面的科特林代码得出的值为-4:

```kt
val y = 3
val z = y.inv()

print("Result is $z")
```

13.9.2 位与

按位“与”是使用“与”运算执行的。它一点一点地比较两个数字。每个数字的二进制序列中的任何相应位置，如果两个位都是 1，就会导致 1 出现在结果数字的相同位置。如果任一位位置包含 0，则结果中出现 0。以我们的两个示例数字为例，如下所示:

```kt
10101011 AND
00000011
========
00000011
```

如我们所见，两个数字都有 1 的唯一位置是最后两个位置。因此，如果我们在 Kotlin 代码中执行此操作，我们会发现结果是 3 (00000011):

```kt
val x = 171
val y = 3
val z = x.and(y)

print("Result is $z")
```

13.9.3 按位“或”

按位“或”还对两个二进制序列进行逐位比较。与“与”运算不同，如果第一个或第二个操作数中有 1，“或”会在结果中放置 1。使用我们的示例数字，结果如下:

```kt
10101011 OR
00000011
========
10101011
```

如果我们在 Kotlin 中使用 or()操作执行此操作，结果将是 171:

```kt
val x = 171
val y = 3
val z = x.or(y)

print("Result is $z")
```

13.9.4 按位异或

按位异或(通常称为异或，并使用异或()运算执行)执行类似于或运算的任务，只是如果两个数字中的一个或其他对应位位置为 1，则结果中会出现 1。如果两个位置都是 1 或 0，则结果中的相应位被设置为 0。例如:

```kt
10101011 XOR
00000011
========
10101000
```

在这种情况下，结果是 10101000，转换为十进制的 168。为了验证这一点，我们可以再次尝试一些科特林代码:

```kt
val x = 171
val y = 3
val z = x.xor(y)

print("Result is $z")
```

执行时，我们从打印中获得以下输出:

```kt
Result is 168
```

13.9.5 按位左移

按位左移将二进制数中的每一位向左移动指定数量的位置。将整数向左移动一个位置会使值翻倍。

当这些位左移时，零被放在最右边空出的位置(低位)。还要注意的是，一旦最左边的(高位)位移动到包含该值的变量的大小之外，这些高位位就会被丢弃:

```kt
10101011 Left Shift one bit
========
101010110
```

在 Kotlin 中，按位左移运算符是使用 shl()操作执行的，传递要移位的位数。例如，向左移动 1 位:

```kt
val x = 171
val z = x.shl(1)

print("Result is $z")
```

当编译和执行时，上面的代码将显示一条消息，说明结果是 342，当转换为二进制时，等于 101010110。

13.9.6 按位右移

如您所料，按位右移与左移相同，只是方向相反。将一个整数向右移动一个位置会产生减半的效果。

请注意，由于我们向右移动，因此无论用于包含结果的数据类型如何，都没有机会保留最低位。结果，低阶位被丢弃。空出的高阶位位置是否用 0 或 1 替换取决于用于指示正数和负数的符号位是否被设置。

```kt
10101011 Right Shift one bit
========
01010101
```

按位右移是使用 shr()操作通过移位计数来执行的:

```kt
val x = 171
val z = x.shr(1)

print("Result is $z")
```

执行时，上述代码将报告移位结果为 85，相当于二进制 01010101。

13.10 总结

运算符和表达式提供了在 Kotlin 代码中操作和计算变量和常量的基本机制。这可以采用最简单的形式，即在表达式中使用加法运算符将两个数字相加，然后使用赋值运算符将结果存储在变量中。操作员分为一系列类别，本章已经介绍了这些类别的详细信息。